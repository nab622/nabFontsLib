<html>
<head>

	<meta charset="UTF-8">

	<script src="js/nabLib.js"></script>
	<script src="js/nabFonts.js"></script>

<style>

input:focus, select:focus, textarea.focus {
    box-shadow: 0px 0px 10px #FF4, inset 0px 0px 10px #FF4;
}

body {
    margin: 0px;
    width: 100vw;
    height: 100vh;
    overflow: hidden;

	flex-direction: row;
    display: flex;

	background-color: #000;
	color: #EEE;
	font-family: 'nabfonts monospace';
	font-size: 14pt;
	font-weight: bold;
}

#navigationPane {
	user-select: none;
}

.characterSampleContainers {
	display: flex;
	flex-wrap: wrap;
	flex: 0 0 200px;
	align-items: stretch;
	padding-bottom: 40px;
}

.characterSamples {
	min-width: 100px;
}

.characterBoxes:hover {
	background-color: #222;
}

.characterBoxes {
	text-align: center;
	border: 2px solid #444;
	padding: 12px;
}

.sampleCharacter {
	margin: 10px;
	user-select: text;
}

.characterHeader {
	font-size: 35%;
	color: #777;
	font-family: 'nabfonts monospace';
	font-weight: bold;
	text-align: left;
}

#fontTitle {
	text-align: center;
	font-size: 36pt;
	font-family: 'nabfonts monospace';
}

#fontAuthor {
	text-align: center;
	font-size: 18pt;
	font-family: 'nabfonts monospace';
}

#fontTags {
	text-align: center;
	font-size: 12pt;
	font-family: 'nabfonts monospace';
}

.fontAuthor {
	color: #4CC;
}

.fontTags {
	color: #CC4;
}

.clickable:hover {
	color: #F62;
}

.clickable {
	cursor: pointer;
}

#fontSize {
	width: 100%;
}

#sampleTextArea:focus {
	box-shadow: 0px 0px 20px #44f, inset 0px 0px 10px #44f;
}

#sampleTextArea {
	background-color: #000;
	color: #FFF;
	text-align: left;
	word-wrap: break-word;
	white-space: pre-wrap;
	margin: 0px;
}

#sampleTextText {
/*
	width: 100%;
*/
}

#nameFilter {
/*
	width: 100%;
*/
}

#allCharacters {
	word-wrap: break-word;
}

#fontSettings {
	padding: 1%;
	flex-shrink: 0;
	overflow-y: hidden;
	overflow-x: hidden;
	display: flex;
	flex-direction: column;
	background-color: #132646;
	user-select: none;
}

#fontDisplayArea {
	padding: 1%;
	overflow-y: scroll;
	min-width: 0;
	user-select: none;
}

.fullWidth {
	display: block;
}

.fullWidth {
	display: block;
}

#authorsDropdown {
	width: 220px;
}

#filteredTagsContainer {
	font-size: 10pt;
}

#unusedTagsContainer {
	font-size: 11pt;
	flex: 1 1;
	overflow-y: scroll;
}

.navigation {
	padding-left: 30px;
	background-color: #122A12;
}

.fontSelectionItem:hover {
	background-color: #942;
}

.fontSelectionItem {
	font-family: 'nabFonts monospace';
	font-weight: bold;
	font-size: 12pt;
	cursor: pointer;
	white-space: nowrap;
}

.fontSelectionSample {
	color: #BBB;
	padding-left: 25px;
}

#fontSelection {
	border: 2px inset #333;
	width: 225px;
	height: 90%;
	overflow-y: scroll;
	overflow-x: hidden;
	color: #FFF;
	font-size: 14pt;
	user-select: none;
}

.fontSelectionColor {
	background-color: #321;
}

.filtersHeader {
	text-align: center;
	font-size: 16pt;
}

.tagHeader {
	color: #F52;
}
	
.tagSubGroup {
	color: #B90;
}
	
.tag {
}

.includedTag:hover {
	color: #9F9;
	text-shadow: 0px 0px 3px #DDD6;
}

.includedTag {
	cursor: pointer;
	color: #0F0;
	font-family: "Heydings Common Icons";
	font-weight: normal;
}

.excludedTag:hover {
	color: #F88;
	text-shadow: 0px 0px 3px #DDD6;
}

.excludedTag {
	cursor: pointer;
	color: #F00;
	font-family: "Heydings Common Icons";
	font-weight: normal;
}

.unusedTag {
	cursor: pointer;
	color: #555;
}

.removeTag {
	color: #960;
	font-size: 90%;
	font-family: "Web Symbols";
}

.tagCount {
	color: #FA0;
}

.textInputContainer {
	display: inline-block;
}

.clearButton::before {
	content: "×";
}

.clearButton:hover {
	color: #F88;
	text-shadow: 0px 0px 3px #DDD6;
}

.clearButton {
	display: inline-block;
	color: #F33;
	font-family: "Web Symbols";
	font-weight: normal;
}

.button:hover {
	background-color: #EEE;
	color: #F90;
	text-shadow: 1px 1px 1px #000;
}

.button {
	color: #EEE;
	border: 2px outset #555;
	border-radius: 25%;
	background-color: #333;
	cursor: pointer;
	text-align: center;
	font-size: 18pt;
	font-weight: normal;
	font-style: normal;
	padding: 0pt 1pt 0pt 1pt;
	display: inline-block;
	text-shadow: 1px 1px 1px #000;
}

.activeButton {
	color: #000;
	background-color: #BBB;
	border-style: inset;
	text-shadow: 1px 1px 1px #EEE;
}

.boldButton {
	font-weight: bold;
	font-size: 14pt;
	line-height: 18pt;
	width: 18pt;
	font-family: "heydings controls";
}

.italicButton {
	font-style: italic;
	text-align: left;
	font-size: 14pt;
	line-height: 18pt;
	width: 18pt;
	font-family: "heydings controls";
}

.prevButton {
	font-style: normal;
	text-align: left;
	font-size: 18pt;
	line-height: 18pt;
	width: 18pt;
	font-family: "heydings controls";
}

.playButton {
	font-style: normal;
	text-align: left;
	font-size: 18pt;
	line-height: 18pt;
	width: 18pt;
	font-family: "heydings controls";
}

.stopButton {
	font-style: normal;
	text-align: left;
	font-size: 18pt;
	line-height: 18pt;
	width: 18pt;
	font-family: "heydings controls";
}

.nextButton {
	font-style: normal;
	text-align: left;
	font-size: 18pt;
	line-height: 18pt;
	width: 18pt;
	font-family: "heydings controls";
}

</style>

<script>

// Defaults
defaultFont = ''
defaultFontSize = 48

fontRotationDelay = 3		// Seconds
rotateFontTimer = null

currentFont = ''
currentFontSize = 0
filters = {}

sampleText = {
	capitalLetters		:	"ABCDEFGHIJKLMNOPQRSTUVWXYZ",
	lowercaseLetters	:	"abcdefghijklmnopqrstuvwxyz",
	punctuation			:	"0123456789+=’'()[]{}<>:,‒–—―…!.«»-‐?\"’“”;/⁄␠·&@*\•^¤¢$€£¥₩₪†‡°¡¿¬#№%‰‱¶′§~¨_|¦⁂☞∴‽※",
	pangrams			:	[ "The quick brown fox jumps over the lazy dog.", "Amazingly few discotheques provide jukeboxes." ]
}

function drawFontSamples() {
	parseSample(sampleText.capitalLetters, capitalLetters)
	parseSample(sampleText.lowercaseLetters, lowercaseLetters)
	parseSample(sampleText.punctuation, punctuation)

	let pangramContainer = document.createElement('div')
	for(let i = 0; i < sampleText.pangrams.length; i++) {
		let newPangram = document.createElement('div')
		newPangram.id = 'pangram' + (i + 1)
		newPangram.className = 'characterSampleContainers fullWidth'
		drawCharacters(sampleText.pangrams[i], newPangram, false)
		pangramContainer.appendChild(newPangram)
	}
	pangrams.appendChild(pangramContainer)

	drawAllCharacters()
}

function parseSample(inputString, element) {
	for(let i = 0; i < inputString.length; i++) {
		drawCharacters(inputString[i], element)
	}
}

function drawAllCharacters(index = 0) {
	let maxChars = 1114112
	let increment = 100000	// Each iteration of this function will render this many, wait, then call itself

	increment += index

	let output = ''
	for(index; index < maxChars && index < increment; index++) {
		output += String.fromCodePoint(index)
	}

	allCharactersOutput.innerHTML += output

	if(index < maxChars) setTimeout(()=>{ drawAllCharacters(index) }, 1000)
}

function drawCharacters(characters, element, sampleChars = true) {
	let newCharacters = document.createElement('div')
	newCharacters.className = 'characterBoxes'

	if(sampleChars) {
		newCharacters.className += ' characterSamples'
		let newCharHeader = document.createElement('span')
		newCharHeader.className = 'characterHeader'
		newCharHeader.appendChild(document.createTextNode(characters.toString()))
		newCharacters.appendChild(newCharHeader)
		newCharacters.appendChild(document.createElement('br'))
	}

	let newText = document.createElement('span')
	newText.appendChild(document.createTextNode(characters.toString()))
	newText.className = 'sampleCharacter'
	newCharacters.appendChild(newText)
	element.appendChild(newCharacters)
}

function changeAllSampleFonts(inputFont, updateHash = true) {
	stop()

	let tempFont = inputFont

	if(typeof(inputFont) !== 'string') {
		console.log('changeAllSampleFonts Error: Invalid input type: \'' + inputFont + '\' (' + typeof(inputFont) + ')!')
		return false
	} else {
		tempFont = getFontData(inputFont)
	}

	if(tempFont == false) {
		console.log('changeAllSampleFonts Error: Invalid font name: \'' + inputFont + '\'!')
		return false
	}

	currentFont = tempFont.name

	if(updateHash) setHashData({ fontName : currentFont })

	for(let i = 0; i < fontSelection.children.length; i++) {
		let temp = 'font ' + currentFont
		if(fontSelection.children[i].id.toLowerCase() == temp.toLowerCase()) {
			fontSelection.children[i].selected = true
			break
		}
	}

	changeFont(sampleTextArea, currentFont, 'Adobe Blank')
	changeFont(pangrams, currentFont, 'Adobe Blank')
	changeFont(capitalLetters, currentFont, 'Adobe Blank')
	changeFont(lowercaseLetters, currentFont, 'Adobe Blank')
	changeFont(punctuation, currentFont, 'Adobe Blank')
	changeFont(allCharacters, currentFont, 'Adobe Blank')

	clearElement(fontTitle)
	clearElement(fontAuthor)
	clearElement(fontTags)

	fontTitle.appendChild(createElement({ elementType: 'span', text: tempFont.name }))

	fontAuthor.appendChild(createElement({ elementType: 'span', text: 'By: ' }))
	for(let i = 0; i < tempFont.authors.length; i++) {
		fontAuthor.appendChild(createElement({ elementType: 'span', className : 'fontAuthor clickable', onclick : ()=>{ changeFilters({ include : { authors : [ tempFont.authors[i] ] } }, 'authors') }, text: tempFont.authors[i] }))
		if(i + 1 < tempFont.authors.length) {
			fontAuthor.appendChild(createElement({ elementType: 'span', text: ', ' }))
		}
	}

	fontTags.appendChild(createElement({ elementType: 'span', text: 'Tags: ' }))
	for(let i = 0; i < tempFont.tags.length; i++) {
		fontTags.appendChild(createElement({ elementType: 'span', className : 'fontTags clickable', onclick : ()=>{ changeFilters({ include : { tags : [ tempFont.tags[i] ] } }, 'tags') }, text: tempFont.tags[i] }))
		if(i + 1 < tempFont.tags.length) {
			fontTags.appendChild(createElement({ elementType: 'span', text: ', ' }))
		}
	}
}

function boldFont(inputElement, boldFont = true) {
	if(boldFont) {
		boldFont = 'bold'
	} else {
		boldFont = 'normal'
	}
	inputElement.style.fontWeight = boldFont
}

function italicFont(inputElement, italicFont = true) {
	if(italicFont) {
		italicFont = 'italic'
	} else {
		italicFont = 'normal'
	}
	inputElement.style.fontStyle = italicFont
}

function setButtonState(button, activeState = true) {
	if(activeState) {
		addClassName(button, 'activeButton')
	} else {
		removeClassName(button, 'activeButton')
	}
}

function setBold(boldActive) {
	setButtonState(boldButton, boldActive)

	boldFont(sampleTextArea, boldActive)
	boldFont(pangrams, boldActive)
	boldFont(capitalLetters, boldActive)
	boldFont(lowercaseLetters, boldActive)
	boldFont(punctuation, boldActive)
	boldFont(allCharacters, boldActive)
}

function setItalic(italicActive) {
	setButtonState(italicButton, italicActive)

	italicFont(sampleTextArea, italicActive)
	italicFont(pangrams, italicActive)
	italicFont(capitalLetters, italicActive)
	italicFont(lowercaseLetters, italicActive)
	italicFont(punctuation, italicActive)
	italicFont(allCharacters, italicActive)
}

function toggleBold() {
	let temp = getHashData()
	if(temp.hasOwnProperty('bold') && temp.bold == true) {
		setHashData({ 'bold' : false })
		return
	}
	setHashData({ 'bold' : true })
}

function toggleItalic() {
	let temp = getHashData()
	if(temp.hasOwnProperty('italic') && temp.italic == true) {
		setHashData({ 'italic' : false })
		return
	}
	setHashData({ 'italic' : true })
}

function changeAllSampleFontSizes(inputFontSize, updateHash = true) {
	currentFontSize = parseInt(inputFontSize)
	if(isNaN(currentFontSize)) currentFontSize = defaultFontSize
	fontSize.value = currentFontSize
	currentFontSize = fontSize.value	//This will force currentFontSize to adhere to the step value of the slider

	if(updateHash) setHashData({ fontSize : parseInt(currentFontSize) })

	sampleTextArea.style.fontSize = currentFontSize.toString() + 'pt'
	pangrams.style.fontSize = currentFontSize.toString() + 'pt'
	capitalLetters.style.fontSize = currentFontSize.toString() + 'pt'
	lowercaseLetters.style.fontSize = currentFontSize.toString() + 'pt'
	punctuation.style.fontSize = currentFontSize.toString() + 'pt'
	allCharacters.style.fontSize = currentFontSize.toString() + 'pt'

	clearElement(fontSizeText)
	fontSizeText.appendChild(createElement({ elementType: 'span', text: currentFontSize + ' pt' }))
	fontSize.title = currentFontSize + ' points'
}

function stop() {
	clearTimeout(rotateFontTimer)
	removeClassName(playButton, 'activeButton')
}

function play() {
	rotateFontTimer = setTimeout(()=>{ next(); play() }, fontRotationDelay * 1000)
	addClassName(playButton, 'activeButton')
}

function next(count = 1) {
	stop()

	let tempIndex = getSelectIndex(fontSelection, null)
	if(tempIndex === null) {
		tempIndex = 0
	} else {
		if(fontSelection.children.length == 0) {
			tempIndex = 0
		} else {
			tempIndex = (tempIndex + count) % fontSelection.children.length
		}
	}

	setSelectIndex(fontSelection, tempIndex)

	currentFont = fontSelection.value
	changeAllSampleFonts(currentFont)
}

function prev(count = 1) {
	stop()

	let tempIndex = getSelectIndex(fontSelection, null)
	
	if(tempIndex === null) {
		tempIndex = 0
	} else {
		if(fontSelection.children.length == 0) {
			tempIndex = 0
		} else {
			tempIndex = (tempIndex - count) % fontSelection.children.length
			if(tempIndex < 0) tempIndex += fontSelection.children.length
		}
	}

	setSelectIndex(fontSelection, tempIndex)

	currentFont = fontSelection.value
	changeAllSampleFonts(currentFont)
}

function changeSampleText(inputText, updateHash = true) {
	let loremIpsum = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
	let newSampleText = loremIpsum

	inputText = inputText.trim()

	if(inputText != '') {
		newSampleText = inputText
		if(updateHash) setHashData({ sampleText: newSampleText })
	} else {
		if(updateHash) setHashData({ sampleText: '' })
	}

	clearElement(sampleTextArea)
	sampleTextArea.appendChild(createElement({ elementType: 'div', className: 'characterBoxes', children: [{ elementType: 'span', className: 'sampleCharacter', text: newSampleText } ] }))
}

function renderFontSelectionList(fontList) {
	clearElement(fontSelection)

	let test = ''
	let temp = currentFont.toLowerCase()
	for(let i = 0; i < fontList.length; i++) {
		test = fontList[i].name.toLowerCase()

		let newOption = { elementType: 'option', id: 'font ' + fontList[i].name, value: fontList[i].name, className: 'fontSelectionItem', onclick: ()=>{ changeAllSampleFonts(fontList[i].name) }, title : fontList[i].name, children: [
			{ elementType: 'span', style: { fontFamily: 'nabFonts monospace' }, text: fontList[i].name },
		] }

		if(test == temp) {
			newOption.selected = true
		}
		fontSelection.appendChild(createElement(newOption))
	}
}

function updatePage() {
	let hashData = getHashData()

	if(hashData.hasOwnProperty('fontName')) {
		if(currentFont.toLowerCase() != hashData.fontName.toLowerCase()) {
			currentFont = hashData.fontName
			changeAllSampleFonts(currentFont, false)
		}
	} else {
		changeAllSampleFonts(defaultFont, false)
	}

	if(hashData.hasOwnProperty('fontSize')) {
		if(currentFontSize != hashData.fontSize) {
			currentFontSize = hashData.fontSize
			changeAllSampleFontSizes(currentFontSize, false)
		}
	} else {
		changeAllSampleFontSizes(defaultFontSize, false)
	}

	if(hashData.hasOwnProperty('sampleText')) {
		if(sampleTextText.value != hashData.sampleText) {
			sampleTextText.value = hashData.sampleText
			changeSampleText(sampleTextText.value, false)
		}
	} else {
		changeSampleText('', false)
	}

	if(hashData.hasOwnProperty('bold') && hashData.bold == true) {
		setBold(true)
	} else {
		setBold(false)
	}

	if(hashData.hasOwnProperty('italic') && hashData.italic == true) {
		setItalic(true)
	} else {
		setItalic(false)
	}

	if(hashData.hasOwnProperty('filters')) {
		if(!inputsAreIdentical(filters, hashData.filters)) {
			// Filters have changed!
			filters = hashData.filters

			let filteredList =	{	
									tags : [],
									authors : [],
									names : [],
									styles : [],
									weights : [],
									fontData : {}
								}
			let metadataList =	{
									tags : [],
									authors : [],
									names : [],
									styles : [],
									weights : [],
								}

			filteredList.fontData = getFilteredFontList(filters)

			for(let i = 0; i < filteredList.fontData.length; i++) {
				fontsLibAddDataToObject(filteredList.fontData[i], metadataList, 'authors')
				fontsLibAddDataToObject(filteredList.fontData[i], metadataList, 'styles')
				fontsLibAddDataToObject(filteredList.fontData[i], metadataList, 'weights')
				fontsLibAddDataToObject(filteredList.fontData[i], metadataList, 'tags')
			}
			renderAsTags(filteredTagsContainer, 'tags')
			renderFontSelectionList(getFilteredFontList(filters))
		}
	} else {
		filters = {}
		renderAsTags(filteredTagsContainer, 'tags')
		renderFontSelectionList(getFilteredFontList(filters))
	}

	// This needs to ALWAYS be updated
	if(filters.include && filters.include.authors && filters.include.authors.length > 0) {
		setSelectValue(authorsDropdown, filters.include.authors[0], false)
	} else {
		setSelectValue(authorsDropdown, '', false)
	}

	if(filters.include && filters.include.name) {
		nameFilter.value = filters.include.name
	} else {
		nameFilter.value = ''
	}
}

function changeDropdown(inputDropdown, metadata) {
	let newValue = getSelectValue(inputDropdown, '')

	let newFilters =	{
							include	:	{
								[metadata]	:	[]
							},
							unused	:	{
								[metadata]	:	[]
							}
						}

	// match is used here to save the trouble of unnecessarily converting the names to lowercase once a match is found.
	// There can only ever be one match in a dropdown
	let match = false
	for(let i = 0; i < customFonts[metadata].length; i++) {
		if(!match && newValue != '' && customFonts[metadata][i].name.toLowerCase() == newValue.toLowerCase()) {
			newFilters.include[metadata].push(customFonts[metadata][i].name)
			match = true
		} else {
			newFilters.unused[metadata].push(customFonts[metadata][i].name)
		}
	}

	changeFilters(newFilters, metadata)
}

function changeFilters(inputFilters, property, updateHash = true) {
	/*	inputFilters MUST be in the following format:
			{
				include	:	{
					name	:	nameSearchTerm,
					authors	:	[ 'author', 'names', 'array' ],
					styles	:	[ 'styles', 'array' ],
					weights	:	[ 'weights', 'array' ],
					tags	:	[ 'tags', 'array' ]
				},
				exclude	:	{
					name	:	nameSearchTerm,
					authors	:	[ 'author', 'names', 'array' ],
					styles	:	[ 'styles', 'array' ],
					weights	:	[ 'weights', 'array' ],
					tags	:	[ 'tags', 'array' ]
				},
				unused	:	{
					name	:	nameSearchTerm,
					authors	:	[ 'author', 'names', 'array' ],
					styles	:	[ 'styles', 'array' ],
					weights	:	[ 'weights', 'array' ],
					tags	:	[ 'tags', 'array' ]
				}
			}
	*/

	let tempFilters = {}
	let temp = getHashData()
	if(temp.hasOwnProperty('filters')) {
		tempFilters = temp.filters
	}

	if(!tempFilters.include) tempFilters.include = {}
	if(!tempFilters.exclude) tempFilters.exclude = {}

	// Remove any 'unused' items from the filter
	if(inputFilters.hasOwnProperty('unused') && inputFilters.unused.hasOwnProperty(property)) {
		for(let i = 0; i < inputFilters.unused[property].length; i++) {
			inputFilters.unused[property][i] = inputFilters.unused[property][i].toLowerCase()
		}

		if(tempFilters.hasOwnProperty('include') && tempFilters.include.hasOwnProperty(property)) {
			for(let i = 0; i < inputFilters.unused[property].length; i++) {
				removeItemFromArray(tempFilters.include[property], inputFilters.unused[property][i], false)
			}
		}

		if(tempFilters.hasOwnProperty('exclude') && tempFilters.exclude.hasOwnProperty(property)) {
			for(let i = 0; i < inputFilters.unused[property].length; i++) {
				removeItemFromArray(tempFilters.exclude[property], inputFilters.unused[property][i], false)
			}
		}
	}

	if(	inputFilters.hasOwnProperty('include') &&
		inputFilters.include.hasOwnProperty(property)) {

		if(	tempFilters.hasOwnProperty('include') &&
			tempFilters.include.hasOwnProperty(property) &&
			Array.isArray(tempFilters.include[property])) {
			tempFilters.include[property] = joinArraysNoDuplicates(tempFilters.include[property], inputFilters.include[property])
		} else {
			tempFilters.include[property] = inputFilters.include[property]
		}
	}

	if(	inputFilters.hasOwnProperty('exclude') &&
		inputFilters.exclude.hasOwnProperty(property)) {

		if(	tempFilters.hasOwnProperty('exclude') &&
			tempFilters.exclude.hasOwnProperty(property) &&
			Array.isArray(tempFilters.exclude[property])) {
			tempFilters.exclude[property] = joinArraysNoDuplicates(tempFilters.exclude[property], inputFilters.exclude[property])
		} else {
			tempFilters.exclude[property] = inputFilters.exclude[property]
		}
	}

	if(tempFilters.include && tempFilters.include[property] && tempFilters.include[property].length == 0) delete tempFilters.include[property]
	if(tempFilters.exclude && tempFilters.exclude[property] && tempFilters.exclude[property].length == 0) delete tempFilters.exclude[property]

	if(updateHash) setHashData({ filters : tempFilters })
}

function renderAsDropdown(outputElement, metadata) {
	let selectOutput = { elementType : 'select', id : metadata + 'Dropdown', children : [] }

	let allOption = ({ elementType: 'option', value : '', text : '-----  All ' + metadata + ' (' + customFonts[metadata].length + ' ' + metadata + ')  -----' })

	let match = false
	for(let i = 0; i < customFonts[metadata].length; i++) {
		let newOption = { elementType: 'option', value : customFonts[metadata][i].name, text : customFonts[metadata][i].name + ' (' + customFonts[metadata][i].count + ' ' + pluralize([ 'font', 'fonts' ], customFonts[metadata][i].count) + ')' }
		if(!match && filters.include && filters.include[metadata] && filters.include[metadata].length > 0) {
			if(customFonts[metadata][i].name.toLowerCase() == filters.include[metadata][0].toLowerCase()) {
				newOption.selected = 'selected'
				match = true
			}
		}
		selectOutput.children.push(newOption)
	}

	if(!match) {
		allOption.selected = 'selected'
	}

	selectOutput.children.unshift(allOption)

	clearElement(outputElement)
	outputElement.appendChild(createElement(selectOutput))

	// This MUST come after createElement, because the element must be defined before the action can be created
	document.getElementById([metadata] + 'Dropdown').onchange = ()=>{ changeDropdown(metadata + 'Dropdown', metadata) }
}

function renderAsTags(outputElement, metadata) {
	let metadataOutput = 	{
								includeData	: [],
								excludeData	: [],
								unusedData	: []
							}

	let match = false
	for(let i = 0; i < customFonts[metadata].length; i++) {
		match = false
		if(filters.hasOwnProperty('include') && filters.include.hasOwnProperty(metadata)) {
			for(let j = 0; j < filters.include[metadata].length; j++) {
				if(filters.include[metadata][j] == customFonts[metadata][i].name.toLowerCase()) {
					// This tag is filtered as an include
					metadataOutput.includeData.push(customFonts[metadata][i])
					match = true
					break
				}
			}
		}

		if(match) continue

		if(filters.hasOwnProperty('exclude') && filters.exclude.hasOwnProperty(metadata)) {
			for(let j = 0; j < filters.exclude[metadata].length; j++) {
				if(filters.exclude[metadata][j] == customFonts[metadata][i].name.toLowerCase()) {
					// This tag is filtered as an exclude
					metadataOutput.excludeData.push(customFonts[metadata][i])
					match = true
					break
				}
			}
		}

		if(match) continue

		metadataOutput.unusedData.push(customFonts[metadata][i])
	}

	clearElement(outputElement)

	if(metadataOutput.includeData.length > 0) {
		outputElement.appendChild(createElement({ elementType: 'div', className: 'tagSubGroup', text : 'Included:' }))
		for(let i = 0; i < metadataOutput.includeData.length; i++) {
			if(metadataOutput.includeData[i].count < 1) continue
			outputElement.appendChild(createElement({ elementType : 'div', title : metadataOutput.includeData[i].name, children : [
				{ elementType : 'span', className : 'tag', children : [
					{ elementType : 'span', className : 'excludedTag removeTag', onclick : ()=>{ changeFilters({ unused : { [metadata] : [ metadataOutput.includeData[i].name ] } }, metadata) }, text : ' × ' },
					{ elementType : 'span', text : metadataOutput.includeData[i].name },
					{ elementType : 'span', className : 'tagCount', text : ' (' + metadataOutput.includeData[i].count + ')' }
				] }
			] }))
		}
		outputElement.appendChild(createElement({ elementType: 'br' }))
	}

	if(metadataOutput.excludeData.length > 0) {
		outputElement.appendChild(createElement({ elementType: 'div', className: 'tagSubGroup', text : 'Excluded:' }))
		for(let i = 0; i < metadataOutput.excludeData.length; i++) {
			if(metadataOutput.excludeData[i].count < 1) continue
			outputElement.appendChild(createElement({ elementType : 'div', title : metadataOutput.excludeData[i].name, children : [
				{ elementType : 'span', className : 'tag', children : [
					{ elementType : 'span', className : 'includedTag removeTag', onclick : ()=>{ changeFilters({ unused : { [metadata] : [ metadataOutput.excludeData[i].name ] } }, metadata) }, text : ' × ' },
					{ elementType : 'span', text : metadataOutput.excludeData[i].name },
					{ elementType : 'span', className : 'tagCount', text : ' (' + metadataOutput.excludeData[i].count + ')' }
				] }
			] }))
		}
		outputElement.appendChild(createElement({ elementType: 'br' }))
	}

	// For scrolling purposes, the unused tags need to be in their own container
	clearElement(unusedTagsContainer)
	let tempElement = { elementType : 'div', children : [] }
	for(let i = 0; i < metadataOutput.unusedData.length; i++) {
		if(metadataOutput.unusedData[i].count < 1) continue
		unusedTagsContainer.appendChild(createElement({ elementType : 'div', title : metadataOutput.unusedData[i].name, children : [
			{ elementType : 'span', className : 'tag', children : [
				{ elementType : 'span', className : 'excludedTag', onclick : ()=>{ changeFilters({ exclude : { [metadata] : [ metadataOutput.unusedData[i].name ] } }, metadata) }, text : ' - ' },
				{ elementType : 'span', className : 'includedTag', onclick : ()=>{ changeFilters({ include : { [metadata] : [ metadataOutput.unusedData[i].name ] } }, metadata) }, text : ' + ' },
				{ elementType : 'span', text : metadataOutput.unusedData[i].name },
				{ elementType : 'span', className : 'tagCount', text : ' (' + metadataOutput.unusedData[i].count + ')' }
			] }
		] }))
	}
//	unusedTagsContainer.appendChild(createElement(tempElement))
}

function changeNameFilter(newText, updateHash = true) {
	if(newText != '') {
		nameFilter.value = newText
	} else {
		if(filters.include && filters.include.name) delete filters.include.name
	}
	changeFilters({ include : { name : newText } }, 'name', updateHash)
}

function clearNameFilter() {
	changeNameFilter('')
	nameFilter.focus()
}

function clearSampleText() {
	changeSampleText('')
	sampleTextText.focus()
}

document.addEventListener("DOMContentLoaded", function(event) {
	drawFontSamples()

	renderAsDropdown(authorsContainer, 'authors')

	// This is declared up above, but it has to be set here, after the font data is parsed
	defaultFont = customFonts.fontData[0].name

	updatePage()

	sampleTextText.oninput = ()=>{ changeSampleText(sampleTextText.value, false) }
	sampleTextText.onchange = ()=>{ changeSampleText(sampleTextText.value) }

	nameFilter.oninput = ()=>{ changeNameFilter(nameFilter.value, false) }
	nameFilter.onchange = ()=>{ changeNameFilter(nameFilter.value) }

	play()
})

</script>
</head>
<body onhashchange="updatePage()">
	<div id="fontSettings">
		<div style="flex: 0 0;">
			Sample text:
			<br>
			<div class="textInputContainer">
				<input type="text" size="20" id="sampleTextText" />
				<div class="clearButton" onclick="clearSampleText()"></div>
			</div>
			<br>
			<br>

			Size: <span id="fontSizeText"></span>
			<div class="slidecontainer">
				<input type="range" min="8" max="300" value="4" step="4" id="fontSize" onchange="changeAllSampleFontSizes(this.value)" />
			</div>
			<br>
				<div id="boldButton" title="Bold" class="button boldButton" onclick="toggleBold()">6</div>
				<div id="italicButton" title="Italic" class="button italicButton" onclick="toggleItalic()">7</div>
			<br>
			<hr width="85%"></hr>
			<div>
				<div class="filtersHeader">
					Filters
				</div>
				<span class="tagHeader">
					Name:
				</span>
				<br>
				<div class="textInputContainer">
					<input type="text" size="20" id="nameFilter" />
					<div class="clearButton" onclick="clearNameFilter()"></div>
				</div>
				<br>
				<br>
				<span class="tagHeader">
					Authors:
				</span>
				<div id="authorsContainer">
				</div>
				<br>
			</div>
		</div>
		<span class="tagHeader">
			Tags:
		</span>
		<div style="flex: 1 1; display: flex; flex-direction: column; overflow: auto;">
			<div id="filteredTagsContainer">
			</div>
			<div id="unusedTagsContainer">
			</div>
		</div>
	</div>

	<div id="navigationPane">
		<div class="navigation">
			<div id="prevButton" title="Previous Font" class="button prevButton" onclick="prev()">&lt;</div>
			<div id="playButton" title="Play" class="button playButton" onclick="play()">P</div>
			<div id="stopButton" title="Stop" class="button stopButton" onclick="stop()">S</div>
			<div id="nextButton" title="Next Font" class="button nextButton" onclick="next()">&gt;</div>
		</div>
		<div class="fontSelectionColor">
			Fonts:
			<br>
			<select id="fontSelection" size="15" class="fontSelectionColor" onchange="changeAllSampleFonts(this.value)">
			</select>
		</div>
	</div>

	<div id="fontDisplayArea">
		<div id="fontTitle">
		</div>
		<div id="fontAuthor">
		</div>
		<div id="fontTags">
		</div>
		<div>
			Sample text:
			<br>
			<pre id="sampleTextArea" class="characterSampleContainers fullWidth"></pre>
		</div>
		<div>
			English pangrams:
			<br>
			<div id="pangrams" class="fullWidth">
			</div>
		</div>
		<div>
			Capital letters:
			<br>
			<div id="capitalLetters" class="characterSampleContainers"></div>
		</div>
		<div>
			Lowercase letters:
			<br>
			<div id="lowercaseLetters" class="characterSampleContainers"></div>
		</div>
		<div>
			Numbers, punctuation &amp; Symbols:
			<br>
			<div id="punctuation" class="characterSampleContainers"></div>
		</div>
		<div>
			All unicode characters:
			<br>
			<div id="allCharacters" class="characterSampleContainers fullWidth">
				<div class="characterBoxes">
					<div id="allCharactersOutput" class="sampleCharacter">
					</div>
				</div>
			</div>
		</div>
	</div>

</body>
</html>
